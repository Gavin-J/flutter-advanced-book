{"./":{"url":"./","title":"简介","keywords":"","body":"作者 q1，一年Flutter工作经验，Flutter教程网 创办者，微信公众号\"Flutter前线\"小编， FlutterCandies开源组织成员，具有： wechat_flutter， nav_router等开源项目作品， 视频课程：Flutter实用例子进阶课程 ， 高仿谷歌翻译项目课程， 目前就职于广州某创业公司， 持续对Flutter社区输出文章资源，目前主要关注移动端行业发展和技术更新迭代，不断进步。 简介 本书主要讲解Flutter进阶，深入原理，以及工作所可能遇到的技术栈和问题解决方案、面试中 可能遇到的问题，以实战角度进行：文案、思维导图、代码示例、工作原理、使用方式进行讲解， 可帮助开发者快速进阶flutter技术。 章节介绍 本书分为多个章节，不确定性，会一直更，直到完善，然后固定章节，目前已有章节： 性能篇、原理篇、面试篇。 持续更新中。。。敬请期待！ "},"chapter1/":{"url":"chapter1/","title":"第一章：性能篇","keywords":"","body":"本章目录 性能优化之局部刷新 "},"chapter1/partial_refresh.html":{"url":"chapter1/partial_refresh.html","title":"1.1：性能优化之局部刷新","keywords":"","body":"partial_refresh.md hahahah "},"chapter2/":{"url":"chapter2/","title":"第二章：原理篇","keywords":"","body":"本章目录 Flutter的setState更新原理和流程 "},"chapter2/setstate.html":{"url":"chapter2/setstate.html","title":"1.1：setState更新原理和流程","keywords":"","body":"分析 Flutter状态类： StatelessWidget：无状态类，没有状态更新，界面一经创建无法更改； StatefulWidget：有状态类，当状态改变，调用setState()方法会触发StatefulWidget的UI状态更新，自定义继承StatefulWidget的子类须重写createState()方法。 也就是只有当我们的类是有状态类的时候才能进行状态刷新，setState也是在State（有状态类）类里 逻辑 调用 setState() 必须是没有调用过 dispose() 方法，不然出错，可通过mounted属性来判断调用此方法是否合法。 if (mounted) { setState(() {}); } setState方法 void setState(VoidCallback fn) { ... _element.markNeedsBuild(); } 清晰的看到在framework.dart内setState方法除了一些条件判断就是：_element.markNeedsBuild(); 那我们看看markNeedsBuild。 Element 类 markNeedsBuild方法 void markNeedsBuild() { assert(_debugLifecycleState != _ElementLifecycle.defunct); // 由于一帧做两次更新有点低效，所以在如果`_active=false` 的时候直接返回。 if (!_active) return;//返回 ... if (dirty) return; // 设置`_dirty = true ` _dirty = true; //调用scheduleBuildFor方法 owner.scheduleBuildFor(this); } 将 element 元素标记为“脏”,并把它添加到全局的“脏”链表里,以便在下一帧更新信号时更新. 这里的“ 脏”链表是待更新的链表，更新过后就不“脏”了。 那我们看看本方法最后调用的scheduleBuildFor方法。 BuildOwner 类 scheduleBuildFor方法 BuildOwner类是widget framework的管理类，它跟踪那些需要重新构建的 widget。 void scheduleBuildFor(Element element) { ... if (element._inDirtyList) { ... _dirtyElementsNeedsResorting = true; return; } if (!_scheduledFlushDirtyElements && onBuildScheduled != null) { _scheduledFlushDirtyElements = true; onBuildScheduled();//回调 } _dirtyElements.add(element);//把element添加到脏元素链表 element._inDirtyList = true; assert(() { if (debugPrintScheduleBuildForStacks) debugPrint('...dirty list is now: $_dirtyElements'); return true; }()); } 把一个 element 添加到 _dirtyElements 链表，主要为了方便当WidgetsBinding.drawFrame中调用 buildScope 的时候能够重构 element。onBuildScheduled()是一个 BuildOwner 的回调。 onBuildScheduled回调在WidgetsBinding的initInstances里初始化。 mixin WidgetsBinding on BindingBase, SchedulerBinding, GestureBinding, RendererBinding, SemanticsBinding { @override void initInstances() { super.initInstances(); _instance = this; // 这里 buildOwner.onBuildScheduled = _handleBuildScheduled; // 赋值onBuildScheduled window.onLocaleChanged = handleLocaleChanged;window.onAccessibilityFeaturesChanged = handleAccessibilityFeaturesChanged; SystemChannels.navigation.setMethodCallHandler(_handleNavigationInvocation); SystemChannels.system.setMessageHandler(_handleSystemMessage); FlutterErrorDetails.propertiesTransformers.add(transformDebugCreator); } } 可以看到Flutter应用启动过程初始化WidgetsBinding时buildOwner.onBuildScheduled回调等于了 _handleBuildScheduled，那现在来看看这个_handleBuildScheduled方法： void _handleBuildScheduled() { //调用ensureVisualUpdate ensureVisualUpdate(); } 可以看到调用ensureVisualUpdate方法，那我们继续走下去。 SchedulerBinding类ensureVisualUpdate方法 void ensureVisualUpdate() { switch (schedulerPhase) { case SchedulerPhase.idle: case SchedulerPhase.postFrameCallbacks: //当schedulerPhase为SchedulerPhase.idle， //SchedulerPhase.postFrameCallbacks时调用scheduleFrame() scheduleFrame(); return; case SchedulerPhase.transientCallbacks: case SchedulerPhase.midFrameMicrotasks: case SchedulerPhase.persistentCallbacks: return; } } schedulerPhase的初始值为SchedulerPhase.idle。SchedulerPhase是一个enum枚举类型， 分别case了SchedulerPhase 的 5 个枚举值： 状态 含义 idle 没有正在处理的帧，可能正在执行的是 WidgetsBinding.scheduleTask，scheduleMicrotask，Timer，事件 handlers，或者其他回调等 transientCallbacks SchedulerBinding.handleBeginFrame 过程， 处理动画状态更新 midFrameMicrotasks 处理 transientCallbacks 阶段触发的微任务（Microtasks） persistentCallbacks WidgetsBinding.drawFrame 和 SchedulerBinding.handleDrawFrame 过程，build/layout/paint 流水线工作 postFrameCallbacks 主要是清理和计划执行下一帧的工作 第二个case调用scheduleFrame()方法 那我们看看scheduler/binding.dart文件的SchedulerBinding类scheduleFrame()方法 void scheduleFrame() { // 这个判断表示只有当APP处于可见状态才会准备调度下一帧方法 if (_hasScheduledFrame || !_framesEnabled) return; assert(() { if (debugPrintScheduleFrameStacks) debugPrintStack( label: 'scheduleFrame() called. Current phase is $schedulerPhase.'); return true; }()); //调用Window 的scheduleFrame方法是一个 native 方法 window.scheduleFrame(); _hasScheduledFrame = true; } 这里的 window.scheduleFrame()方法是一个Native方法， 由于本人并没有扎实的原生经验所以下方借鉴了袁辉辉大佬的部分讲解， lib/ui/window.dart文件 Window类 (Native) void scheduleFrame() native 'Window_scheduleFrame'; window是Flutter引擎中跟图形相关接口打交道的核心类。 ScheduleFrame(C++) window.cc文件 void ScheduleFrame(Dart_NativeArguments args) { // 看下方 RuntimeController::ScheduleFrame UIDartState::Current()->window()->client()->ScheduleFrame(); } 通过RegisterNatives()完成native方法的注册，“Window_scheduleFrame”所对应的native方法如上所示。 RuntimeController::ScheduleFrame 所在文件：flutter/runtime/runtime_controller.cc void RuntimeController::ScheduleFrame() { client_.ScheduleFrame(); // 看下面Engine::ScheduleFrame } Engine::ScheduleFrame 所在文件：flutter/shell/common/engine.cc void Engine::ScheduleFrame(bool regenerate_layer_tree) { animator_->RequestFrame(regenerate_layer_tree); } 这里推荐查看袁辉辉大佬的：Flutter渲染机制—UI线程 文中小节[2.1]介绍Engine::ScheduleFrame()经过层层调用，最终会注册Vsync回调。 等待下一次vsync信号的到来， 然后再经过层层调用最终会调用到Window::BeginFrame()。 Window::BeginFrame 所在文件：flutter/lib/ui/window/window.cc void Window::BeginFrame(fml::TimePoint frameTime) { std::shared_ptr dart_state = library_.dart_state().lock(); if (!dart_state) return; tonic::DartState::Scope scope(dart_state); int64_t microseconds = (frameTime - fml::TimePoint()).ToMicroseconds(); DartInvokeField(library_.value(), \"_beginFrame\", { Dart_NewInteger(microseconds), }); //执行MicroTask UIDartState::Current()->FlushMicrotasksNow(); DartInvokeField(library_.value(), \"_drawFrame\", {}); } Window::BeginFrame()过程主要工作： 执行_beginFrame 执行FlushMicrotasksNow 执行_drawFrame 可见，Microtask位于beginFrame和drawFrame之间，那么Microtask的耗时会影响ui绘制过程。 handleBeginFrame 文件所在: lib/src/scheduler/binding.dart SchedulerBinding类 void handleBeginFrame(Duration rawTimeStamp) { Timeline.startSync('Frame', arguments: timelineWhitelistArguments); _firstRawTimeStampInEpoch ??= rawTimeStamp; _currentFrameTimeStamp = _adjustForEpoch(rawTimeStamp ?? _lastRawTimeStamp); if (rawTimeStamp != null) _lastRawTimeStamp = rawTimeStamp; profile(() { _profileFrameNumber += 1; _profileFrameStopwatch.reset(); _profileFrameStopwatch.start(); }); //此时阶段等于SchedulerPhase.idle; _hasScheduledFrame = false; try { Timeline.startSync('Animate', arguments: timelineWhitelistArguments); _schedulerPhase = SchedulerPhase.transientCallbacks; //执行动画的回调方法 final Map callbacks = _transientCallbacks; _transientCallbacks = {}; callbacks.forEach((int id, _FrameCallbackEntry callbackEntry) { if (!_removedIds.contains(id)) _invokeFrameCallback(callbackEntry.callback, _currentFrameTimeStamp, callbackEntry.debugStack); }); _removedIds.clear(); } finally { _schedulerPhase = SchedulerPhase.midFrameMicrotasks; } } 该方法主要功能是遍历_transientCallbacks，执行相应的Animate操作， 可通过scheduleFrameCallback()/cancelFrameCallbackWithId()来完成添加和删除成员， 再来简单看看这两个方法。 handleDrawFrame 文件所在：lib/src/scheduler/binding.dart SchedulerBinding类 void handleDrawFrame() { assert(_schedulerPhase == SchedulerPhase.midFrameMicrotasks); Timeline.finishSync(); // 标识结束\"Animate\"阶段 try { _schedulerPhase = SchedulerPhase.persistentCallbacks; //执行PERSISTENT FRAME回调 for (FrameCallback callback in _persistentCallbacks) _invokeFrameCallback(callback, _currentFrameTimeStamp); _schedulerPhase = SchedulerPhase.postFrameCallbacks; // 执行POST-FRAME回调 final List localPostFrameCallbacks = List.from(_postFrameCallbacks); _postFrameCallbacks.clear(); for (FrameCallback callback in localPostFrameCallbacks) _invokeFrameCallback(callback, _currentFrameTimeStamp); } finally { _schedulerPhase = SchedulerPhase.idle; Timeline.finishSync(); //标识结束”Frame“阶段 profile(() { _profileFrameStopwatch.stop(); _profileFramePostEvent(); }); _currentFrameTimeStamp = null; } } 该方法主要功能： 遍历_persistentCallbacks，执行相应的回调方法，可通过addPersistentFrameCallback()注册，一旦注册后不可移除，后续每一次frame回调都会执行； 遍历_postFrameCallbacks，执行相应的回调方法，可通过addPostFrameCallback()注册，handleDrawFrame()执行完成后会清空_postFrameCallbacks内容。 UI 的绘制逻辑【附加】 UI 的绘制逻辑是在 Render 树中实现的，所以这里还来细看 RendererBinding 的逻辑。 RendererBinding 【附加】 void initInstances() { ... //监听Window对象的事件 ui.window ..onMetricsChanged = handleMetricsChanged ..onTextScaleFactorChanged = handleTextScaleFactorChanged ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged ..onSemanticsAction = _handleSemanticsAction; //添加PersistentFrameCallback addPersistentFrameCallback(_handlePersistentFrameCallback); } addPersistentFrameCallback 中添加 _handlePersistentFrameCallback 最终调用了 drawFrame 而 WidgetsBinding 重写了 RendererBinding 中的 drawFrame() 方法。最终发现我们又回到了 WidgetsBinding 这个类中，在 WidgetsBinding 中 drawFrame 的实现如下： @override void drawFrame() { ... try { if (renderViewElement != null) // 重构需要更新的element buildOwner.buildScope(renderViewElement); super.drawFrame(); //调用RendererBinding的drawFrame()方法 buildOwner.finalizeTree(); } } 在上面 scheduleBuildFor 方法介绍中有提到：\"scheduleBuildFor 是把一个 element 添加到 _dirtyElements 链表，以便当[WidgetsBinding.drawFrame]中调用 buildScope 的时候能够重构 element。onBuildScheduled()是一个 BuildOwner 的回调\"。在 drawFrame 中调用 buildOwner.buildScope(renderViewElement)更新 elements。 void buildScope(Element context, [ VoidCallback callback ]) { ... while (index 得出 条件判断 1.生命周期判断 2.是否可以进行刷新：mounted 添加脏链表 _dirty = true 1.“脏”链表是待更新的链表 2.更新过后就不“脏”了 3._active=false 的时候直接返回 管理类 1.告诉管理类方法自己需要被重新构建： owner.scheduleBuildFor(this) 调用 window.scheduleFrame() =》native 方法 RegisterNatives()完成native方法的注册 最终会注册Vsync回调。 等待下一次vsync信号的到来， 然后再经过层层调用最终会调用到 Window::BeginFrame() UI 的绘制逻辑是在 Render 树中实现的 更新帧信号来临从而刷新需要重构的界面 在 drawFrame 中调用 buildOwner.buildScope(renderViewElement)更新 elements "},"chapter3/":{"url":"chapter3/","title":"第三章：面试篇","keywords":"","body":"本章目录 dart部分面试题 Flutter优缺点以及理念架构 "},"chapter3/dart_interview.html":{"url":"chapter3/dart_interview.html","title":"1.1：dart部分面试题","keywords":"","body":"dart部分 目前还在整理中。。。。 "},"chapter3/flutter_framwork.html":{"url":"chapter3/flutter_framwork.html","title":"1.2：Flutter优缺点以及理念架构","keywords":"","body":" 1.简单的说说Flutter优缺点以及理念架构： 答案： 优点 热重载（Hot Reload），利用Android Studio直接一个ctrl+s就可以保存并重载，模拟器立马就可以看见效果，相比原生冗长的编译过程强很多； 一切皆为Widget的理念，对于Flutter来说，手机应用里的所有东西都是Widget，通过可组合的空间集合、丰富的动画库以及分层课扩展的架构实现了富有感染力的灵活界面设计； 借助可移植的GPU加速的渲染引擎以及高性能本地代码运行时以达到跨平台设备的高质量用户体验。 简单来说就是：最终结果就是利用Flutter构建的应用在运行效率上会和原生应用差不多。 缺点 不支持热更新； 三方库很少，需要自己造轮子（不过现在越来越多了，社区也越来越强了）； dart语言编写，掌握该语言的开发者很少（不过有其他语言基础的掌握起来也特别容易）。 理念架构 Flutter 主要分为 Framework 和 Engine，我们基于Framework 开发App，运行在 Engine 上。Engine 是 Flutter 的独立虚拟机，由它适配和提供跨平台支持，目前猜测 Flutter 应用程序在 Android 上，是直接运行 Engine 上 所以在是不需要Dalvik虚拟机。（这是比kotlin更彻底，抛弃JVM的纠缠？ ）   得益于 Engine 层，Flutter 甚至不使用移动平台的原生控件， 而是使用自己 Engine 来绘制 Widget （Flutter的显示单元），而 Dart 代码都是通过 AOT 编译为平台的原生代码，所以 Flutter 可以 直接与平台通信，不需要JS引擎的桥接。同时 Flutter 唯一要求系统提供的是 canvas，以实现UI的绘制。 2.简单的解释下Flutter的FrameWork层和Engine层： 答案： FrameWork层 Flutter的顶层是用drat编写的框架（SDK），它实现了一套基础库，包含Material（Android风格UI）和Cupertino（iOS风格）的UI界面，下面是通用的Widgets（组件），之后是一些动画、绘制、渲染、手势库等。这个纯 Dart实现的 SDK被封装为了一个叫作 dart:ui的 Dart库。我们在使用 Flutter写 App的时候，直接导入这个库即可使用组件等功能。 Engine层 Skia是Google的一个 2D的绘图引擎库，其前身是一个向量绘图软件，Chrome和 Android均采用 Skia作为绘图引擎。Skia提供了非常友好的 API，并且在图形转换、文字渲染、位图渲染方面都提供了友好、高效的表现。Skia是跨平台的，所以可以被嵌入到 Flutter的 iOS SDK中，而不用去研究 iOS闭源的 Core Graphics / Core Animation。Android自带了 Skia，所以 Flutter Android SDK要比 iOS SDK小很多。 第二是Dart 运行时环境 第三文本渲染布局引擎。 Flutter每日一面目录大全 "}}