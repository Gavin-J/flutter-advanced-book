{"./":{"url":"./","title":"简介","keywords":"","body":"作者 q1，一年Flutter工作经验，Flutter教程网 创办者，微信公众号\"Flutter前线\"小编， FlutterCandies开源组织成员，具有： wechat_flutter， nav_router等开源项目作品， 视频课程：Flutter实用例子进阶课程 ， 高仿谷歌翻译项目课程， 目前就职于广州某创业公司， 持续对Flutter社区输出文章资源，主要关注移动端行业发展和技术更新迭代，不断进步。 简介 本书主要讲解Flutter进阶，深入原理，以及工作所可能遇到的技术栈和问题解决方案、面试中 可能遇到的问题，以实战角度进行：文案、思维导图、代码示例、工作原理、使用方式进行讲解， 可帮助开发者快速进阶flutter技术。 章节介绍 本书分为多个章节，不确定性，会一直更，直到完善，然后固定章节，目前已有章节： 进阶篇、原理篇、面试篇。 本书暂未想过发版实体书，主要发布电子版供大家学习参考。 持续更新中。。。敬请期待！ "},"chapter1/":{"url":"chapter1/","title":"第一章：进阶篇","keywords":"","body":"本章目录 局部刷新优化性能 屏幕适配之组件应用 屏幕适配之屏幕算法 "},"chapter1/partial_refresh.html":{"url":"chapter1/partial_refresh.html","title":"1.1：局部刷新优化性能","keywords":"","body":"1.1：局部刷新优化性能 Flutter状态类： StatelessWidget：无状态类，没有状态更新，界面一经创建无法更改； StatefulWidget：有状态类，当状态改变，调用setState()方法会触发StatefulWidget的UI状态更新，自定义继承StatefulWidget的子类须重写createState()方法。 案例： 当我们调用有状态类的setState方法时会遍历每一个子Widget的State.build刷新状态， 这将是一笔很大的性能开销，所以我们需要使用局部刷新来进行优化。 普通刷新方式 class TestRoute extends StatefulWidget { @override _TestRouteState createState() => _TestRouteState(); } class _TestRouteState extends State { int count = 0; @override Widget build(BuildContext context) { return new FlatButton( onPressed: () { setState(() => count++); }, child: new Text('$count'), ); } } 一个有状态类定义一个变量然后按钮的事件调用setState让这个变量进行刷新， 使用GlobalKey局部刷新方式 我们还是用上面的例子，只是通过GlobalKey的方式只刷新局部的Text， class TestRoute extends StatefulWidget { @override _TestRouteState createState() => _TestRouteState(); } class _TestRouteState extends State { int count = 0; GlobalKey textKey = GlobalKey(); @override Widget build(BuildContext context) { return new Column( mainAxisAlignment: MainAxisAlignment.center, children: [ new TextWidget(textKey), //需要更新的Text new FlatButton( onPressed: () { count++; // 这里我们只给他值变动，状态刷新交给下面的Key事件 textKey.currentState.onPressed(count); }, child: new Text('按钮 $count'), ), ], ); } } // 封装的文本组件Widget class TextWidget extends StatefulWidget { final Key key; // 接收一个Key TextWidget(this.key); @override State createState() => TextWidgetState(); } class TextWidgetState extends State { String _text = \"0\"; @override Widget build(BuildContext context) { return new Text(_text); } void onPressed(int count) { setState(() => _text = count.toString()); } } 效果： 可以明显的看到按钮的count并无变动，但需要更新的文本组件更新了值，已经完美实现了局部刷新。 实现原理： textKey是一个GlobalKey类型的Key范型为TextWidgetState（封装的文本&&有状态类）， 所以这个Key可以通过currentState方法调用到类里面的onPressed方法， 而onPressed方法刚好有调用setState来刷新局部状态。 "},"chapter1/screen_widget.html":{"url":"chapter1/screen_widget.html","title":"1.2：屏幕适配之组件应用","keywords":"","body":"分析 Flutter可用适配组件： Expanded、Flexible、Spacer、AspectRatio、Wrap.... "},"chapter1/screen_algorithm.html":{"url":"chapter1/screen_algorithm.html","title":"1.3：屏幕适配之屏幕算法","keywords":"","body":"屏幕适配之屏幕算法 既然是算法适配就必然少不了获取屏幕宽高，我们用的就是媒体查询（MediaQuery）， 下面是封装方法过后的，当然直接使用也是可以的： // 整屏宽度 double winWidth(BuildContext context) { return MediaQuery.of(context).size.width; } // 整屏高度 double winHeight(BuildContext context) { return MediaQuery.of(context).size.height; } // 顶部padding double winTop(BuildContext context) { return MediaQuery.of(context).padding.top; } // 底部padding double winBottom(BuildContext context) { return MediaQuery.of(context).padding.bottom; } // 左边padding double winLeft(BuildContext context) { return MediaQuery.of(context).padding.left; } // 右边padding double winRight(BuildContext context) { return MediaQuery.of(context).padding.right; } // 状态栏高度 double statusBarHeight(BuildContext context) { return MediaQueryData.fromWindow(window).padding.top; } // 工具栏高度 double navigationBarHeight(BuildContext context) { return kToolbarHeight; } // AppBar高度 double topBarHeight(BuildContext context) { return kToolbarHeight + MediaQueryData.fromWindow(window).padding.top; } // 键盘高度：键盘未弹出则为0 double keyBordHeight(BuildContext context) { return MediaQuery.of(context).viewInsets.bottom; } "},"chapter2/":{"url":"chapter2/","title":"第二章：原理篇","keywords":"","body":"本章目录 Flutter的setState更新原理和流程 Flutter的生命周期 "},"chapter2/setstate.html":{"url":"chapter2/setstate.html","title":"1.1：setState更新原理和流程","keywords":"","body":"分析 Flutter状态类： StatelessWidget：无状态类，没有状态更新，界面一经创建无法更改； StatefulWidget：有状态类，当状态改变，调用setState()方法会触发StatefulWidget的UI状态更新，自定义继承StatefulWidget的子类须重写createState()方法。 也就是只有当我们的类是有状态类的时候才能进行状态刷新，setState也是在State（有状态类）类里 解析 ： framework.dart文件State类 调用 setState() 必须是没有调用过 dispose() 方法，不然出错，可通过mounted属性来判断调用此方法是否合法。 if (mounted) { setState(() {}); } setState方法 void setState(VoidCallback fn) { ... _element.markNeedsBuild(); } setState方法除了一些条件判断就是：_element.markNeedsBuild(); 那我们看看markNeedsBuild。 Element 类 markNeedsBuild方法 void markNeedsBuild() { assert(_debugLifecycleState != _ElementLifecycle.defunct); // 由于一帧做两次更新有点低效，所以在如果`_active=false` 的时候直接返回。 if (!_active) return;//返回 ... if (dirty) return; // 设置`_dirty = true ` _dirty = true; //调用scheduleBuildFor方法 owner.scheduleBuildFor(this); } 将 element 元素标记为“脏”,并把它添加到全局的“脏”链表里,以便在下一帧更新信号时更新. 这里的“ 脏”链表是待更新的链表，更新过后就不“脏”了。 那我们看看本方法最后调用的scheduleBuildFor方法。 BuildOwner 类 scheduleBuildFor方法 BuildOwner类是widget framework的管理类，它跟踪那些需要重新构建的 widget。 void scheduleBuildFor(Element element) { ... if (element._inDirtyList) { ... _dirtyElementsNeedsResorting = true; return; } if (!_scheduledFlushDirtyElements && onBuildScheduled != null) { _scheduledFlushDirtyElements = true; onBuildScheduled();//回调 } _dirtyElements.add(element);//把element添加到脏元素链表 element._inDirtyList = true; assert(() { if (debugPrintScheduleBuildForStacks) debugPrint('...dirty list is now: $_dirtyElements'); return true; }()); } 把一个 element 添加到 _dirtyElements 链表，主要为了方便当WidgetsBinding.drawFrame中调用 buildScope 的时候能够重构 element。onBuildScheduled()是一个 BuildOwner 的回调。 onBuildScheduled回调在WidgetsBinding的initInstances里初始化。 mixin WidgetsBinding on BindingBase, SchedulerBinding, GestureBinding, RendererBinding, SemanticsBinding { @override void initInstances() { super.initInstances(); _instance = this; // 这里 buildOwner.onBuildScheduled = _handleBuildScheduled; // 赋值onBuildScheduled window.onLocaleChanged = handleLocaleChanged;window.onAccessibilityFeaturesChanged = handleAccessibilityFeaturesChanged; SystemChannels.navigation.setMethodCallHandler(_handleNavigationInvocation); SystemChannels.system.setMessageHandler(_handleSystemMessage); FlutterErrorDetails.propertiesTransformers.add(transformDebugCreator); } } 可以看到Flutter应用启动过程初始化WidgetsBinding时buildOwner.onBuildScheduled回调等于了 _handleBuildScheduled，那现在来看看这个_handleBuildScheduled方法： void _handleBuildScheduled() { //调用ensureVisualUpdate ensureVisualUpdate(); } 可以看到调用ensureVisualUpdate方法，那我们继续走下去。 SchedulerBinding类ensureVisualUpdate方法 void ensureVisualUpdate() { switch (schedulerPhase) { case SchedulerPhase.idle: case SchedulerPhase.postFrameCallbacks: //当schedulerPhase为SchedulerPhase.idle， //SchedulerPhase.postFrameCallbacks时调用scheduleFrame() scheduleFrame(); return; case SchedulerPhase.transientCallbacks: case SchedulerPhase.midFrameMicrotasks: case SchedulerPhase.persistentCallbacks: return; } } schedulerPhase的初始值为SchedulerPhase.idle。SchedulerPhase是一个enum枚举类型， 分别case了SchedulerPhase 的 5 个枚举值： 状态 含义 idle 没有正在处理的帧，可能正在执行的是 WidgetsBinding.scheduleTask，scheduleMicrotask，Timer，事件 handlers，或者其他回调等 transientCallbacks SchedulerBinding.handleBeginFrame 过程， 处理动画状态更新 midFrameMicrotasks 处理 transientCallbacks 阶段触发的微任务（Microtasks） persistentCallbacks WidgetsBinding.drawFrame 和 SchedulerBinding.handleDrawFrame 过程，build/layout/paint 流水线工作 postFrameCallbacks 主要是清理和计划执行下一帧的工作 第二个case调用scheduleFrame()方法 那我们看看scheduler/binding.dart文件的SchedulerBinding类scheduleFrame()方法 void scheduleFrame() { // 这个判断表示只有当APP处于可见状态才会准备调度下一帧方法 if (_hasScheduledFrame || !_framesEnabled) return; assert(() { if (debugPrintScheduleFrameStacks) debugPrintStack( label: 'scheduleFrame() called. Current phase is $schedulerPhase.'); return true; }()); //调用Window 的scheduleFrame方法是一个 native 方法 window.scheduleFrame(); _hasScheduledFrame = true; } 这里的 window.scheduleFrame()方法是一个Native方法， 由于本人并没有扎实的原生经验所以下方借鉴了袁辉辉大佬的部分讲解， lib/ui/window.dart文件 Window类 (Native) void scheduleFrame() native 'Window_scheduleFrame'; window是Flutter引擎中跟图形相关接口打交道的核心类。 ScheduleFrame(C++) window.cc文件 void ScheduleFrame(Dart_NativeArguments args) { // 看下方 RuntimeController::ScheduleFrame UIDartState::Current()->window()->client()->ScheduleFrame(); } 通过RegisterNatives()完成native方法的注册，“Window_scheduleFrame”所对应的native方法如上所示。 RuntimeController::ScheduleFrame 所在文件：flutter/runtime/runtime_controller.cc void RuntimeController::ScheduleFrame() { client_.ScheduleFrame(); // 看下面Engine::ScheduleFrame } Engine::ScheduleFrame 所在文件：flutter/shell/common/engine.cc void Engine::ScheduleFrame(bool regenerate_layer_tree) { animator_->RequestFrame(regenerate_layer_tree); } 这里推荐查看袁辉辉大佬的：Flutter渲染机制—UI线程 文中小节[2.1]介绍Engine::ScheduleFrame()经过层层调用，最终会注册Vsync回调。 等待下一次vsync信号的到来， 然后再经过层层调用最终会调用到Window::BeginFrame()。 Window::BeginFrame 所在文件：flutter/lib/ui/window/window.cc void Window::BeginFrame(fml::TimePoint frameTime) { std::shared_ptr dart_state = library_.dart_state().lock(); if (!dart_state) return; tonic::DartState::Scope scope(dart_state); int64_t microseconds = (frameTime - fml::TimePoint()).ToMicroseconds(); DartInvokeField(library_.value(), \"_beginFrame\", { Dart_NewInteger(microseconds), }); //执行MicroTask UIDartState::Current()->FlushMicrotasksNow(); DartInvokeField(library_.value(), \"_drawFrame\", {}); } Window::BeginFrame()过程主要工作： 执行_beginFrame 执行FlushMicrotasksNow 执行_drawFrame 可见，Microtask位于beginFrame和drawFrame之间，那么Microtask的耗时会影响ui绘制过程。 handleBeginFrame 文件所在: lib/src/scheduler/binding.dart SchedulerBinding类 void handleBeginFrame(Duration rawTimeStamp) { Timeline.startSync('Frame', arguments: timelineWhitelistArguments); _firstRawTimeStampInEpoch ??= rawTimeStamp; _currentFrameTimeStamp = _adjustForEpoch(rawTimeStamp ?? _lastRawTimeStamp); if (rawTimeStamp != null) _lastRawTimeStamp = rawTimeStamp; profile(() { _profileFrameNumber += 1; _profileFrameStopwatch.reset(); _profileFrameStopwatch.start(); }); //此时阶段等于SchedulerPhase.idle; _hasScheduledFrame = false; try { Timeline.startSync('Animate', arguments: timelineWhitelistArguments); _schedulerPhase = SchedulerPhase.transientCallbacks; //执行动画的回调方法 final Map callbacks = _transientCallbacks; _transientCallbacks = {}; callbacks.forEach((int id, _FrameCallbackEntry callbackEntry) { if (!_removedIds.contains(id)) _invokeFrameCallback(callbackEntry.callback, _currentFrameTimeStamp, callbackEntry.debugStack); }); _removedIds.clear(); } finally { _schedulerPhase = SchedulerPhase.midFrameMicrotasks; } } 该方法主要功能是遍历_transientCallbacks，执行相应的Animate操作， 可通过scheduleFrameCallback()/cancelFrameCallbackWithId()来完成添加和删除成员， 再来简单看看这两个方法。 handleDrawFrame 文件所在：lib/src/scheduler/binding.dart SchedulerBinding类 void handleDrawFrame() { assert(_schedulerPhase == SchedulerPhase.midFrameMicrotasks); Timeline.finishSync(); // 标识结束\"Animate\"阶段 try { _schedulerPhase = SchedulerPhase.persistentCallbacks; //执行PERSISTENT FRAME回调 for (FrameCallback callback in _persistentCallbacks) _invokeFrameCallback(callback, _currentFrameTimeStamp); _schedulerPhase = SchedulerPhase.postFrameCallbacks; // 执行POST-FRAME回调 final List localPostFrameCallbacks = List.from(_postFrameCallbacks); _postFrameCallbacks.clear(); for (FrameCallback callback in localPostFrameCallbacks) _invokeFrameCallback(callback, _currentFrameTimeStamp); } finally { _schedulerPhase = SchedulerPhase.idle; Timeline.finishSync(); //标识结束”Frame“阶段 profile(() { _profileFrameStopwatch.stop(); _profileFramePostEvent(); }); _currentFrameTimeStamp = null; } } 该方法主要功能： 遍历_persistentCallbacks，执行相应的回调方法，可通过addPersistentFrameCallback()注册，一旦注册后不可移除，后续每一次frame回调都会执行； 遍历_postFrameCallbacks，执行相应的回调方法，可通过addPostFrameCallback()注册，handleDrawFrame()执行完成后会清空_postFrameCallbacks内容。 UI 的绘制逻辑【附加】 UI 的绘制逻辑是在 Render 树中实现的，所以这里还来细看 RendererBinding 的逻辑。 RendererBinding 【附加】 void initInstances() { ... //监听Window对象的事件 ui.window ..onMetricsChanged = handleMetricsChanged ..onTextScaleFactorChanged = handleTextScaleFactorChanged ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged ..onSemanticsAction = _handleSemanticsAction; //添加PersistentFrameCallback addPersistentFrameCallback(_handlePersistentFrameCallback); } addPersistentFrameCallback 中添加 _handlePersistentFrameCallback 最终调用了 drawFrame 而 WidgetsBinding 重写了 RendererBinding 中的 drawFrame() 方法。最终发现我们又回到了 WidgetsBinding 这个类中，在 WidgetsBinding 中 drawFrame 的实现如下： @override void drawFrame() { ... try { if (renderViewElement != null) // 重构需要更新的element buildOwner.buildScope(renderViewElement); super.drawFrame(); //调用RendererBinding的drawFrame()方法 buildOwner.finalizeTree(); } } 在上面 scheduleBuildFor 方法介绍中有提到：\"scheduleBuildFor 是把一个 element 添加到 _dirtyElements 链表，以便当[WidgetsBinding.drawFrame]中调用 buildScope 的时候能够重构 element。onBuildScheduled()是一个 BuildOwner 的回调\"。在 drawFrame 中调用 buildOwner.buildScope(renderViewElement)更新 elements。 void buildScope(Element context, [ VoidCallback callback ]) { ... while (index 得出 条件判断 1.生命周期判断 2.是否可以进行刷新：mounted 添加脏链表 _dirty = true 1.“脏”链表是待更新的链表 2.更新过后就不“脏”了 3._active=false 的时候直接返回 管理类 1.告诉管理类方法自己需要被重新构建： owner.scheduleBuildFor(this) 调用 window.scheduleFrame() =》native 方法 RegisterNatives()完成native方法的注册 最终会注册Vsync回调。 等待下一次vsync信号的到来， 然后再经过层层调用最终会调用到 Window::BeginFrame() UI 的绘制逻辑是在 Render 树中实现的 更新帧信号来临从而刷新需要重构的界面 在 drawFrame 中调用 buildOwner.buildScope(renderViewElement)更新 elements "},"chapter3/":{"url":"chapter3/","title":"第三章：面试篇","keywords":"","body":"本章目录 dart部分面试题 Flutter优缺点以及理念架构 "},"chapter3/dart_interview.html":{"url":"chapter3/dart_interview.html","title":"1.1：dart部分面试题","keywords":"","body":"dart部分 目前还在整理中。。。。 "},"chapter3/flutter_framwork.html":{"url":"chapter3/flutter_framwork.html","title":"1.2：Flutter优缺点以及理念架构","keywords":"","body":" 1.简单的说说Flutter优缺点以及理念架构： 答案： 优点 热重载（Hot Reload），利用Android Studio直接一个ctrl+s就可以保存并重载，模拟器立马就可以看见效果，相比原生冗长的编译过程强很多； 一切皆为Widget的理念，对于Flutter来说，手机应用里的所有东西都是Widget，通过可组合的空间集合、丰富的动画库以及分层课扩展的架构实现了富有感染力的灵活界面设计； 借助可移植的GPU加速的渲染引擎以及高性能本地代码运行时以达到跨平台设备的高质量用户体验。 简单来说就是：最终结果就是利用Flutter构建的应用在运行效率上会和原生应用差不多。 缺点 不支持热更新； 三方库很少，需要自己造轮子（不过现在越来越多了，社区也越来越强了）； dart语言编写，掌握该语言的开发者很少（不过有其他语言基础的掌握起来也特别容易）。 理念架构 Flutter 主要分为 Framework 和 Engine，我们基于Framework 开发App，运行在 Engine 上。Engine 是 Flutter 的独立虚拟机，由它适配和提供跨平台支持，目前猜测 Flutter 应用程序在 Android 上，是直接运行 Engine 上 所以在是不需要Dalvik虚拟机。（这是比kotlin更彻底，抛弃JVM的纠缠？ ）   得益于 Engine 层，Flutter 甚至不使用移动平台的原生控件， 而是使用自己 Engine 来绘制 Widget （Flutter的显示单元），而 Dart 代码都是通过 AOT 编译为平台的原生代码，所以 Flutter 可以 直接与平台通信，不需要JS引擎的桥接。同时 Flutter 唯一要求系统提供的是 canvas，以实现UI的绘制。 2.简单的解释下Flutter的FrameWork层和Engine层： 答案： FrameWork层 Flutter的顶层是用drat编写的框架（SDK），它实现了一套基础库，包含Material（Android风格UI）和Cupertino（iOS风格）的UI界面，下面是通用的Widgets（组件），之后是一些动画、绘制、渲染、手势库等。这个纯 Dart实现的 SDK被封装为了一个叫作 dart:ui的 Dart库。我们在使用 Flutter写 App的时候，直接导入这个库即可使用组件等功能。 Engine层 Skia是Google的一个 2D的绘图引擎库，其前身是一个向量绘图软件，Chrome和 Android均采用 Skia作为绘图引擎。Skia提供了非常友好的 API，并且在图形转换、文字渲染、位图渲染方面都提供了友好、高效的表现。Skia是跨平台的，所以可以被嵌入到 Flutter的 iOS SDK中，而不用去研究 iOS闭源的 Core Graphics / Core Animation。Android自带了 Skia，所以 Flutter Android SDK要比 iOS SDK小很多。 第二是Dart 运行时环境 第三文本渲染布局引擎。 "},"chapter2/life_cycle.html":{"url":"chapter2/life_cycle.html","title":"1.2：生命周期","keywords":"","body":"生命周期 Flutter生命周期相对于android的Activity，ta存在于framework.dart的State类， 实测 写个有状态类并混入WidgetsBindingObserver配合监听特殊状态及其一个按钮，调用setState， 给生命周期的方法新增打印： import 'package:flutter/material.dart'; void main() => runApp(new MyApp()); class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( title: '生命周期', home: new LiftCycle(), ); } } class LiftCycle extends StatefulWidget { @override _LiftCycleState createState() => _LiftCycleState(); } class _LiftCycleState extends State with WidgetsBindingObserver { int count = 0; @override void initState() { super.initState(); WidgetsBinding.instance.addObserver(this); print('初始化 initState'); } @override void didUpdateWidget(LiftCycle oldWidget) { super.didUpdateWidget(oldWidget); print('组件更新 didUpdateWidget'); } @override void reassemble() { super.reassemble(); print('重新安装 reassemble'); } @override void deactivate() { super.deactivate(); print('停用 deactivate'); } @override void dispose() { super.dispose(); WidgetsBinding.instance.removeObserver(this); print('销毁 dispose'); } @override void didChangeAppLifecycleState(AppLifecycleState state) { super.didChangeAppLifecycleState(state); print('特殊状态 state：$state'); } @override void setState(fn) { super.setState(fn); print('状态刷新 setState'); } @override Widget build(BuildContext context) { return new Scaffold( appBar: new AppBar(title: new Text('生命周期')), body: new Center( child: new FlatButton( onPressed: () => setState(() => count++), child: new Text('$count'), ), ), ); } @override void didChangeDependencies() { super.didChangeDependencies(); print('依赖改变 didChangeDependencies'); } } 然后我们现在来看看打印流程，正常打开App什么都不操作，就打印了： I/flutter (15867): 初始化 initState I/flutter (15867): 依赖改变 didChangeDependencies I/flutter (15867): 重新安装 reassemble I/flutter (15867): 组件更新 didUpdateWidget 热重载打印： I/flutter (16141): 重新安装 reassemble I/flutter (16141): 组件更新 didUpdateWidget Reloaded 0 of 468 libraries in 186ms. 点击按钮打印： I/flutter (16141): 状态刷新 setState // count也+1了，说明重新调用过build。 流程图 "}}